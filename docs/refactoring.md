Backward Compatible Refactoring
===============================

Nirum is designed to marshal well-typed data for networking.  That means types
defined in Nirum IDL are shared with other programs over the network.
"Other programs" mean they usually aren't deployed together.
Even if some of your types defined in Nirum IDL was evolved and the changes
were deployed to some programs that use them, some other programs still works
as the types were not changed yet until the changes are deployed to all involved
programs together.

To help types defined in Nirum IDL to be possible to be evolved with backward
compatibility, Nirum types provide several properties.


Behind names for old names
--------------------------

The most of identifiers in Nirum IDL have a facial name and a behind name.
By default, these two names are the same.  For example, the following two
declarations are equivalent:

    record money (decimal amount, currency currency);

    record money/money (decimal amount/amount, currency currency/currency);

A facial name is a descriptive identifier for humans.  Object codes generated
by Nirum compiler have identifiers named after facial names.

On the other hand, a behind name is an arbitrary identifier for programs.
JSON payloads produced by serializers (that are generated by Nirum compiler)
have identifiers named after behind names.

The following declaration shows a record and its fields having behind names
different from their facial names:

    record point2d/point (
        float64 left/x,
        float64 top/y,
    );

The above IDL becomes to the following Python code for example (although it
approximates details):

~~~ python
class Point2d:
    def __init__(self, left: float, top: float) -> None:
        self.left = left
        self.top = top
~~~

For example, `Point(left=1.23, top=4.56)` value is serialized to the following
JSON payload:

~~~ json
{
    "_type": "point",
    "x": 1.23,
    "y": 4.56
}
~~~

Note that the above JSON payload names its type and fields after the behind
names like `point`, `x` and `y`, whereas the above Python code names its class
and attributes after the facial names like `Point2d`, `left` and `top`.

Separating a facial name from a behind name is useful when to rename
a misleading name (or an outdated name) to a more clear name (or an up-to-date
name).


Making field optional
---------------------

An option type modifier (`?`) indicates a field can be `null` in JSON payloads.
Fortunately making a field which had disallowed `null` to allow `null` does not
require any structural changes of JSON payloads.  In other words, every valid
JSON payload that a field disallowing `null` accepts is also accepted by
the same field but of `null` allowance.

On the other hand, when it comes to reversed, optional fields cannot be
required without any compatible breakage.  Also, if two programs communicate
each other, one deserializing and receiving payloads has to be deployed before
other one serializing and sending payloads.
